/* Auto-generated app.js - local-file friendly (no fetch) */

/* === Optional toggle === */
const CONFIRM_BURN_QUESTION = false; // if true -> confirm before burning a question (no points / duel back after reveal / wrong auto)
/* === Intro screen config === */

/* === Questions === */
const QUESTIONS = {
  "meta": {
    "title": "×× ×™ ×•×”×¡×™×¤×•×¨ ×©×œ× ×•",
    "version": "1.0",
    "board": { "rows": 7, "cols": 6 },
    "categoriesOrder": ["history", "places", "figures", "values", "symbols", "achievements"]
  },
  "categories": {
    "history": {
      "label": "×”×™×¡×˜×•×¨×™×”",
      "questions": [
        { "id": "history-1", "points": 10, "type": "for_everyone", "autoScore": true,
          "question": "×œ××™ × ×××¨: \"×œ×š ×œ×š ×××¨×¦×š, ×××•×œ×“×ª×š ×•××‘×™×ª ××‘×™×š ××œ ×”××¨×¥ ××©×¨ ××¨××š\"?",
          "options": ["××‘×¨×”× ××‘×™× ×•", "×™×¦×—×§ ××‘×™× ×•", "×™×¢×§×‘ ××‘×™× ×•", "××©×” ×¨×‘× ×•"],
          "answer": "××‘×¨×”× ××‘×™× ×•", "hint": "" },

        { "id": "history-2", "points": 15, "type": "personal", "autoScore": true,
          "question": "××™×–×” ×—×’ ×—×•×’×’×™× ×›×–×›×¨×•×Ÿ ×œ×™×¦×™××ª ××¦×¨×™×? ×•××™×–×• ××¦×•×•×” ×‘×—×’ ×”×™× ×–×›×¨×•×Ÿ ×œ×ª×§×•×¤×”?",
          "options": [ "×©×‘×•×¢×•×ª ×•×¡×¤×™×¨×ª ×”×¢×•××¨", "×¤×•×¨×™× ×•×§×¨×™××ª ××’×™×œ×”", "×¤×¡×— ×•××›×™×œ×ª ××¦×”" ,"×¡×•×›×•×ª ×•×™×©×™×‘×” ×‘×¡×•×›×”" ],
          "answer": "×¤×¡×— ×•××›×™×œ×ª ××¦×”", "hint": "" },

        { "id": "history-3", "points": 20, "type": "duel",
          "image": "design/duel.jpg",
          "question": "×›×œ ×§×‘×•×¦×” ××•××¨×ª ×‘×ª×•×¨×” ××—×“ ××¢×©×¨×ª ×”×“×™×‘×¨×•×ª. 5 ×©× ×™×•×ª ×‘×œ×™ ×ª×©×•×‘×” â€” × ×™×¦×—×•×Ÿ ×œ×§×‘×•×¦×” ×”×©× ×™×”.",
          "options": [], "answer": "", "hint": "" },

        { "id": "history-4", "points": 5, "type": "regular",
          "question": "×× ×• 10 ××§×•××•×ª/××ª×¨×™× ×‘××¨×¥ (×›×ª×™×‘×” ×¢×œ ×“×£ ×•×”×¦×’×”).",
          "options": [],
          "answer": "×™×¨×•×©×œ×™×, ×¦×¤×ª, ×©×“×” ×‘×•×§×¨, ×˜×›× ×™×•×Ÿ, ×–×›×¨×•×Ÿ ×™×¢×§×‘, ××™×œ×ª, ××•×©×‘×” ×›× ×¨×ª, ×§×‘×¨ ×”×¨××‘\"×, ×§×‘×¨ ×¨×—×œ, ××˜×•×œ×”",
          "hint": "" },

        { "id": "history-5", "points": 15, "type": "personal", "autoScore": true,
          "image": "design/beytHamikdash.jpg",
          "question": "××™ ×‘× ×” ××ª ×‘×™×ª ×”××§×“×© ×”×¨××©×•×Ÿ?",
          "options": ["×©××•×œ ×”××œ×š", "×“×•×“ ×”××œ×š", "×©×œ××” ×”××œ×š", "×¨×—×‘×¢× ×”××œ×š"],
          "answer": "×©×œ××” ×”××œ×š", "hint": "" },

        { "id": "history-6", "points": 5, "type": "regular", "autoScore": true,
          "question": "×‘×™×Ÿ ××™×œ×• ×©× ×™× ×”×™×™×ª×” ××œ×—××ª ×”×¢×•×œ× ×”×©× ×™×”?",
          "options": ["1939â€“1945", "1956â€“1958", "1947â€“1949", "1914â€“1918"],
          "answer": "1939â€“1945", "hint": "" },

        { "id": "history-7", "points": 5, "type": "regular", "autoScore": true,
          "image": "design/atzmaut.jpg",
          "question": "×›××” ×× ×©×™× ×—×ª×•××™× ×¢×œ ××’×™×œ×ª ×”×¢×¦×××•×ª?",
          "options": ["52", "25", "37", "12"],
          "answer": "37", "hint": "" }
      ]
    },

    "places": {
      "label": "××§×•××•×ª",
      "questions": [
        { "id": "places-1", "points": 20, "type": "duel", "autoScore": true,
          "image": "design/duel.jpg"
          "question": "×”×¨ ×”×‘×™×ª â€” ×¢\"×¤ ×”××¡×•×¨×ª ×”×™×”×•×“×™×ª, ××” ××™×•×—×“ ×‘××§×•× ×”×–×”?",
          "options": ["×¢×œ×™×• × ×‘× ×” ×‘×™×ª ×”××§×“×© ×”×¨××©×•×Ÿ ×•×”×©× ×™", "×©× × ×§×¨×¢ ×™× ×¡×•×£", "×©× × ×™×ª× ×” ×”×ª×•×¨×”", "×©× × ×‘× ×ª×” ×—×•××ª ×”×¢×™×¨ ×”×¨××©×•× ×” ×‘×™××™ ×™×”×•×©×¢"],
          "answer": "×¢×œ×™×• × ×‘× ×” ×‘×™×ª ×”××§×“×© ×”×¨××©×•×Ÿ ×•×”×©× ×™", "hint": "××™×Ÿ ×’×œ×’×œ ×”×¦×œ×”" },

        { "id": "places-2", "points": 5, "type": "regular", "autoScore": true,
          "question": "×”×›× ×¡×ª â€” ××”×• ×©× × ×¨×“×£ ×œ×›× ×¡×ª?",
          "options": ["×”×¨×©×•×ª ×”××‘×¦×¢×ª", "×‘×™×ª ×”××©×¤×˜ ×”×¢×œ×™×•×Ÿ", "×”×¨××©×•×ª ×”××—×•×§×§×ª", "××©×¨×“ ×¨××© ×”×××©×œ×”"],
          "answer": "×”×¨×©×•×ª ×”××—×•×§×§×ª", "hint": "" },

        { "id": "places-3", "points": 5, "type": "regular", "autoScore": true,
          "question": "×©×¢×¨ ×”××¨×™×•×ª â€” ××™×–×” ××™×¨×•×¢ ××›×•× ×Ÿ ××¨×¢ ×‘××§×•× ×”×–×”?",
          "options": ["×¤×¨×™×¦×ª ×”×¦× ×—× ×™× ×œ×¢×™×¨ ×”×¢×ª×™×§×” ×‘××œ×—××ª ×©×©×ª ×”×™××™× (1967)", "×—×ª×™××ª ××’×™×œ×ª ×”×¢×¦×××•×ª", "×”×§××ª ×”×›× ×¡×ª ×”×¨××©×•× ×”", "×§×¨×‘ ×ª×œ ×—×™"],
          "answer": "×¤×¨×™×¦×ª ×”×¦× ×—× ×™× ×œ×¢×™×¨ ×”×¢×ª×™×§×” ×‘××œ×—××ª ×©×©×ª ×”×™××™× (1967)", "hint": "" },

        { "id": "places-4", "points": 5, "type": "regular", "autoScore": true,
          "question": "×™×“ ×•×©× â€” ××” ×¤×™×¨×•×© ×”×‘×™×˜×•×™ \"×—×¡×™×“×™ ××•××•×ª ×”×¢×•×œ×\"?",
          "options": ["× ×™×¦×•×œ×™ ×©×•××” ×©×§×™×‘×œ×• ××–×¨×—×•×ª ×™×©×¨××œ×™×ª", "×™×”×•×“×™× ×©×¢×œ×• ×œ××¨×¥ ×œ×¤× ×™ ×§×•× ×”××“×™× ×”", "×œ×•×—××™ ××—×ª×¨×•×ª ×‘×ª×§×•×¤×ª ×”×× ×“×˜", "×œ×Ö¾×™×”×•×“×™× ×©×”×¦×™×œ×• ×™×”×•×“×™× ×‘×©×•××”"],
          "answer": "×œ×Ö¾×™×”×•×“×™× ×©×”×¦×™×œ×• ×™×”×•×“×™× ×‘×©×•××”", "hint": "" },

        { "id": "places-5", "points": 5, "type": "regular",
          "question": "×× ×• ×©×œ×•×©×” ××§×•××•×ª/××–×•×¨×™× ×‘××¨×¥ ×©×§×¨×•×™×™× ×¢×œ ×©× ×”×©×‘×˜×™× ×©×”×ª×™×™×©×‘×• ×©×.",
          "options": [],
          "answer": "×“×•×’×××•×ª: ×’×•×© ×“×Ÿ (×“×Ÿ), ××˜×” ×™×”×•×“×” (×™×”×•×“×”), ×¨××ª ×× ×©×” (×× ×©×”), ××¢×œ×” ××¤×¨×™× (××¤×¨×™×), ××˜×” ×–×‘×•×œ×•×Ÿ (×–×‘×•×œ×•×Ÿ).",
          "hint": "" },

        { "id": "places-6", "points": 15, "type": "personal", "autoScore": true,
          "question": "×‘××™×–×• ×¢×™×¨ ×‘××¨×¥ ×¦×•×œ××” ×”×ª××•× ×” ×”×‘××”? (×œ×”×¦×™×’ ×ª××•× ×”)",
          "image": "design/eilat_ink_flag.jpg",
          "options": ["×—×™×¤×”", "×™×¨×•×©×œ×™×", "××™×œ×ª", "×‘××¨ ×©×‘×¢"],
          "answer": "××™×œ×ª", "hint": "×“×’×œ ×”×“×™×• / ××•× ×¨×©×¨×©" },

        { "id": "places-7", "points": 10, "type": "for_everyone",
          "question": "×–×”×• ××ª ×”×ª××•× ×•×ª ×”×‘××•×ª (×›×œ ×ª××•× ×” = 2 × ×§×³): ×›×•×ª×œ, ××¢×¨×ª ×”××›×¤×™×œ×”, ××¦×“×”, ×™× ×”××œ×—, ×‘× ×™×™× ×™ ×¢×–×¨×™××œ×™.",
          "options": [],
          "answer": "×›×•×ª×œ / ××¢×¨×ª ×”××›×¤×™×œ×” / ××¦×“×” / ×™× ×”××œ×— / ×‘× ×™×™× ×™ ×¢×–×¨×™××œ×™.",
          "hint": "×¡×”\"×› 10 × ×§×³" }
      ]
    },

    "figures": {
      "label": "×“××•×™×•×ª",
      "questions": [
        { "id": "figures-1", "points": 15, "type": "personal", "autoScore": true,
          "question": "××™ ×›×ª×‘ ××ª ×¡×¤×¨ ×ª×”×™×œ×™×?",
          "options": ["×“×•×“ ×”××œ×š", "×©×œ××” ×”××œ×š", "××©×” ×¨×‘× ×•", "×©××•××œ ×”× ×‘×™×"],
          "answer": "×“×•×“ ×”××œ×š", "hint": "" },

        { "id": "figures-2", "points": 20, "type": "duel",
          "question": "×“×•Ö¾×§×¨×‘: × ×›×•×Ÿ/×œ× × ×›×•×Ÿ ×¢×œ ××¡×ª×¨ ×”××œ×›×” (×›×œ ×ª×©×•×‘×” × ×›×•× ×” = 4 × ×§×³). 1) ××¡×ª×¨ ×”×™×™×ª×” ××©×ª×• ×©×œ ×”××Ÿ. 2) ××¡×ª×¨ ×”×œ×›×” ×œ××¨××•×Ÿ ××¨×¦×•×Ÿ ×›×“×™ ×œ×‘×—×•×¨ ×‘×”. 3) ××¡×ª×¨ ×¦××” ×©×œ×•×©×” ×™××™× ×•×©×œ×•×©×” ×œ×™×œ×•×ª. 4) ××¡×ª×¨ × ×ª×œ×ª×” ×¢×œ ×”×¢×¥ ×›×™ ××¨×“×” ×‘××œ×š. 5) ××¡×ª×¨ ×¢×©×ª×” ×©×ª×™ ××©×ª×”×•×ª ×œ××—×©×•×•×¨×•×© ×•×œ×”××Ÿ ×™×•× ××—×¨×™ ×™×•×.",
          "options": [], "answer": "1) ×œ× × ×›×•×Ÿ. 2) ×œ× × ×›×•×Ÿ. 3) × ×›×•×Ÿ. 4) ×œ× × ×›×•×Ÿ. 5) × ×›×•×Ÿ.", "hint": "××™×Ÿ ×’×œ×’×œ ×”×¦×œ×”" },

        { "id": "figures-3", "points": 5, "type": "regular", "autoScore": true,
          "question": "×”×× ×”×™×’ ×”×¨××©×•×Ÿ ×©×œ ×¢× ×™×©×¨××œ (××™ ×”×•×‘×™×œ ××ª ×”×¢× ×‘×™×¦×™××ª ××¦×¨×™×)?",
          "options": ["×“×•×“ ×”××œ×š", "×™×”×•×©×¢ ×‘×Ÿ × ×•×Ÿ", "××”×¨×Ÿ ×”×›×”×Ÿ", "××©×” ×¨×‘× ×•"],
          "answer": "××©×” ×¨×‘× ×•", "hint": "" },

        { "id": "figures-4", "points": 5, "type": "regular",
          "question": "×—×ª××ª×™ ×¢×œ ××’×™×œ×ª ×”×¢×¦×××•×ª, ×× ×™ ×¨××© ×”×××©×œ×” ×”×¨×‘×™×¢×™ ×©×œ ××“×™× ×ª ×™×©×¨××œ. ×©× ××©×¤×—×ª×™ ×”×¨××©×•×Ÿ ×”×™×” ×××™×¨×¡×•×Ÿ, ×”×™×™×ª×™ ×¨×”\"× ×‘×–××Ÿ ××œ×—××ª ×™×•× ×”×›×™×¤×•×¨×™×â€¦ ××™ ×× ×™?",
          "options": [], "answer": "×’×•×œ×“×” ×××™×¨.", "hint": "" },

        { "id": "figures-5", "points": 10, "type": "for_everyone",
          "question": "××•×¦×’×ª ×ª××•× ×” â€” ×–×”×• ××ª ×”×“××•×ª ×•××” ×¤×•×¢×œ×”.",
          "image": "design/einstein.jpg",
          "options": [],
          "answer": "××œ×‘×¨×˜ ××™×™× ×©×˜×™×™×Ÿ â€” ×¤×™×–×™×§××™ ×™×”×•×“×™; ×××¦×™×/××¤×ª×— ×ª×•×¨×ª ×”×™×—×¡×•×ª.",
          "hint": "" },

        { "id": "figures-6", "points": 15, "type": "personal",
          "question": "×‘×©× ×™ ×—×œ×§×™×: 1) ××™ ×”×™×” ×©\"×™ ×¢×’× ×•×Ÿ? 2) ××” ×”× ×¨××©×™ ×”×ª×™×‘×•×ª ×©\"×™?",
          "options": [],
          "answer": "1) ×¡×•×¤×¨ ×¢×‘×¨×™, ×—×ª×Ÿ ×¤×¨×¡ × ×•×‘×œ ×œ×¡×¤×¨×•×ª. 2) ×©××•××œ ×™×•×¡×£.",
          "hint": "" },

        { "id": "figures-7", "points": 10, "type": "for_everyone",
          "question": "××™ ×”×™×” ×”××¡×˜×¨×•× ××•×˜ ×”×™×©×¨××œ×™ ×”×¨××©×•×Ÿ?",
          "options": [],
          "answer": "××™×œ×Ÿ ×¨××•×Ÿ.",
          "hint": "" }
      ]
    },

    "values": {
      "label": "×¢×¨×›×™×",
      "questions": [
        { "id": "values-1", "points": 15, "type": "personal", "autoScore": true,
          "question": "××” ×”× ×¨××©×™ ×”×ª×™×‘×•×ª ×’×\"×—?",
          "options": ["×’××™×œ×•×ª ×—×¡×“", "×’××¨× ×•×—×¡×™×“×•×ª", "×’××•×œ ×—×•×“×©×™", "×’×•×£ ×× ×”×œ ×—×™× ×•×š"],
          "answer": "×’××™×œ×•×ª ×—×¡×“", "hint": "" },

        { "id": "values-2", "points": 5, "type": "regular",
          "question": "××™×–×• ×¦×“×§×” ×’×“×•×œ×” ×™×•×ª×¨: ×œ×¡×™×™×¢ ×œ××“× ×‘××¦×™××ª ×¢×‘×•×“×” ××• ×œ×ª×ª ×œ×• ×¦×“×§×”?",
          "options": [], "answer": "×œ×¡×™×™×¢ ×‘××¦×™××ª ×¢×‘×•×“×” (×œ×¢×–×•×¨ ×œ×• ×œ×¢××•×“ ×¢×œ ×¨×’×œ×™×•).", "hint": "" },

        { "id": "values-3", "points": 5, "type": "regular", "autoScore": true,
          "question": "×××™ ×œ×•××“×™× ××ª ×”×¢×¨×š ×©×œ ×”×›× ×¡×ª ××•×¨×—×™× ×•×××™×–×” ××™×¨×•×¢?",
          "options": [" ××‘×¨×”× ××‘×™× ×• â€” ×”×›× ×¡×ª ×”××•×¨×—×™× ×œ×©×œ×•×©×ª ×”××œ××›×™×", "××©×” ×¨×‘× ×• â€” ×§×¨×™×¢×ª ×™× ×¡×•×£ ×¢×‘×•×¨ ×™×©×¨××œ", "×™×•×¡×£ â€” ×”×›× ×¡×ª ×”××•×¨×—×™× ×œ××©×¤×—×ª×• ×œ××¦×¨×™×", "×™×”×•×©×¢ ×‘×Ÿ × ×•×Ÿ â€” ×—×¦×™×™×ª ×”×™×¨×“×Ÿ ×¢×‘×•×¨ ×”××•×¨×—×™× ×©×œ×•"],
          "answer": "××‘×¨×”× ××‘×™× ×• â€” ×”×›× ×¡×ª ×”××•×¨×—×™× ×œ×©×œ×•×©×ª ×”××œ××›×™×", "hint": "" },

        { "id": "values-4", "points": 15, "type": "personal",
          "question": "××©××™×¢×™× ××ª ×”×©×™×¨ \"××œ×™×¢×–×¨ ×‘×Ÿ ×™×”×•×“×”\" (×‘×™×ª ×¨××©×•×Ÿ ×‘×œ×™ ×¤×–××•×Ÿ). ×¢×œ ××™ × ×›×ª×‘ ×”×©×™×¨ ×•××” ×”×•× × ×™×¡×” ×œ×§×“×?",
          "options": [], "answer": "××œ×™×¢×–×¨ ×‘×ŸÖ¾×™×”×•×“×” â€” ×”×—×™×™×” ××ª ×”×©×¤×” ×”×¢×‘×¨×™×ª.", "hint": "" },

        { "id": "values-5", "points": 10, "type": "for_everyone",
          "question": "×× ×™ ××ª× ×” ×©×¢× ×™×©×¨××œ ×§×™×‘×œ ×‘××™×•×—×“. ×××– ×•×¢×“ ×”×™×•× ×ª×¨×‘×•×™×•×ª ×¨×‘×•×ª ×œ××“×• ××¢× ×™×©×¨××œ. ××•×œ×™ ×¨××©×•×Ÿ, ××•×œ×™ ×©×™×©×™ â€” ××‘×œ ×”××§×•×¨ ×–×” ×× ×™â€¦ ××™ ×× ×™?",
          "options": [], "answer": "×©×‘×ª.", "hint": "" },

        { "id": "values-6", "points": 20, "type": "duel",
          "question": "×“×•Ö¾×§×¨×‘: ×’×™××˜×¨×™×” ×©×œ ×”×¤×¡×•×§ \"×•Ö·×Ö²×”Ö·×‘Ö°×ªÖ¶Ö¼× ×Ö¶×ª-×”Ö·×’ÖµÖ¼×¨ ×›Ö´Ö¼×™-×’Öµ×¨Ö´×™× ×”Ö±×™Ö´×™×ªÖ¶× ×‘Ö°Ö¼×Ö¶×¨Ö¶×¥ ×Ö´×¦Ö°×¨Ö¸×™Ö´×\". ××™ ××’×™×¢ ×¨××©×•×Ÿ ×œ×ª×©×•×‘×” ×”× ×›×•× ×”?",
          "options": [], "answer": "2480", "hint": "××™×Ÿ ×’×œ×’×œ ×”×¦×œ×”" },

        { "id": "values-7", "points": 10, "type": "for_everyone",
          "question": "×× ×™ ××•×¤×™×¢ ×‘×¢×©×¨×ª ×”×“×™×‘×¨×•×ª ×‘×™×—×¡ ×œ××©×¤×—×”, ×›×‘×¡×™×¡ ×œ×—×‘×¨×” ××ª×•×§× ×ª, ×›××¦×•×•×” ×©×¦×¨×™×š ×œ×¢×©×•×ª ×•×œ× ×œ×”×™×× ×¢ ××× ×”. ××” ×× ×™?",
          "options": [], "answer": "×›×™×‘×•×“ ×”×•×¨×™× (×›×‘×“ ××ª ××‘×™×š ×•××ª ×××š).", "hint": "" }
      ]
    },

    "symbols": {
      "label": "×¡××œ×™×",
      "questions": [
        { "id": "symbols-1", "points": 5, "type": "regular", "autoScore": true,
          "question": "×××™×–×” ××œ×× ×˜ ×™×”×•×“×™ ××—×¨ ×”×’×™×¢×• ×©× ×™ ×¤×¡×™ ×”×ª×›×œ×ª ×‘×“×’×œ ×™×©×¨××œ?",
          "image": "design/flag.jpg",
          "options": ["×”×˜×œ×™×ª", "×”×—× ×•×›×™×™×”", "×”×©×•×¤×¨", "×”××–×•×–×”"],
          "answer": "×”×˜×œ×™×ª", "hint": "" },

        { "id": "symbols-2", "points": 10, "type": "for_everyone", "autoScore": true,
          "question": "××™ ×›×ª×‘ ××ª \"×”×ª×§×•×•×”\"?",
          "options": ["××”×•×“ ×× ×•×¨", "×—×™×™× × ×—××Ÿ ×‘×™××œ×™×§", "×©××•×œ ×˜×©×¨× ×™×—×•×‘×¡×§×™", "× ×¤×ª×œ×™ ×”×¨×¥ ××™××‘×¨"],
          "answer": "× ×¤×ª×œ×™ ×”×¨×¥ ××™××‘×¨", "hint": "" },

        { "id": "symbols-3", "points": 15, "type": "personal",
          "question": "××” ×”×¡××œ ×©×œ ×”××“×™× ×” ×•×××™×¤×” ×”×’×™×¢×• ×”×¡××œ×™× ×©×‘×•?",
          "options": [], "answer": "×× ×•×¨×” ××”××§×“×©; ×¢×œ×™ ×–×™×ª ×›×¡××œ ×œ×©×œ×•× (×œ××©×œ ××ª×™×‘×ª × ×—/× ×‘×•××ª ×–×›×¨×™×” â€” ××¡×¤×™×§×” ×ª×©×•×‘×” ××—×ª).", "hint": "" },

        { "id": "symbols-4", "points": 15, "type": "personal",
          "question": "××” ×”× ×¨××©×™ ×”×ª×™×‘×•×ª ×ª× \"×š?",
          "options": [], "answer": "×ª×•×¨×”, × ×‘×™××™×, ×›×ª×•×‘×™×.", "hint": "" },

        { "id": "symbols-5", "points": 5, "type": "regular", "autoScore": true,
          "question": "××” ×™×© ×‘×ª×•×š ×”××–×•×–×”?",
          "options": ["×§×œ×£ ×¢× ×¤×¨×©×™×•×ª \"×©××¢\" ×•\"×•×”×™×” ×× ×©××•×¢\"", "××˜×‘×¢ ×›×¡×£ ×§×˜×Ÿ", "×“×£ ×¢× \"×”×ª×§×•×•×”\"", "××‘×§×” ××™×•×—×“×ª ×œ×‘×¨×›×”"],
          "answer": "×§×œ×£ ×¢× ×¤×¨×©×™×•×ª \"×©××¢\" ×•\"×•×”×™×” ×× ×©××•×¢\"", "hint": "" },

        { "id": "symbols-6", "points": 20, "type": "duel",
          "question": "×“×•Ö¾×§×¨×‘: ××•××¨×™× ×›××” ×©×™×•×ª×¨ ×©×™×¨×™ ×™×¨×•×©×œ×™× ×ª×•×¨Ö¾×ª×•×¨. ××™ ×©××—×¨×™ 5 ×©× ×™×•×ª ×œ× ××•×¦× â€” ××¤×¡×™×“.",
          "options": [], "answer": "", "hint": "××™×Ÿ ×’×œ×’×œ ×”×¦×œ×”" },

        { "id": "symbols-7", "points": 10, "type": "for_everyone",
          "question": "×‘××™×–×” ×ª××¨×™×š ×¢×‘×¨×™ ×•×œ×•×¢×–×™ × ×›×ª×‘×” ××’×™×œ×ª ×”×¢×¦×××•×ª? ×•××™×¤×”?",
          "options": [], "answer": "×”×³ ×‘××™×™×¨ ×ª×©\"×—, 14.5.1948, ×‘×‘×™×ª ×“×™×–× ×’×•×£ (××•×–×™××•×Ÿ ×ª\"× ×”×™×©×Ÿ).", "hint": "" }
      ]
    },

    "achievements": {
      "label": "×”×™×©×’×™×",
      "questions": [
        { "id": "achievements-1", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×—×•×¡×¨ ××™× ×‘×©×˜×— ××“×‘×¨×™ â€” ××” ×”×¤×ª×¨×•×Ÿ ×”×™×©×¨××œ×™?",
          "options": [], "answer": "×”×ª×¤×œ×ª ××™×.", "hint": "" },

        { "id": "achievements-2", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×¡×’×™×“×” ×œ××œ×™×œ×™ ××‘×Ÿ ×•×—×•××¨ â€” ××” ×”×¨×¢×™×•×Ÿ/×”×¤×ª×¨×•×Ÿ ×©×”×‘×™× ×¢× ×™×©×¨××œ?",
          "options": [], "answer": "×××•× ×” ×‘×Ö¾×œ ××—×“.", "hint": "" },

        { "id": "achievements-3", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: × ×™×¦×•×œ ×× ×¨×’×™×” ×–××™× ×” â€” ××” ×”×¤×ª×¨×•×Ÿ ×”×™×©×¨××œ×™ ×”× ×¤×•×¥?",
          "options": [], "answer": "×“×•×“×™ ×©××©.", "hint": "" },

        { "id": "achievements-4", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×“××’×” ×œ×¢×•×‘×“ â€” ××” ×”×¢×™×§×¨×•×Ÿ/×”×¤×ª×¨×•×Ÿ?",
          "options": [], "answer": "×”×©×‘×ª.", "hint": "" },

        { "id": "achievements-5", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×©×™××•×¨ ×××’×¨×™ ××™×“×¢ ×•×ª×•×›× ×•×ª â€” ××” ×”×¤×ª×¨×•×Ÿ (×œ×¤×™ ×”××©×—×§)?",
          "options": [], "answer": "×“×™×¡×§ ××•×Ÿ ×§×™.", "hint": "" },

        { "id": "achievements-6", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×”×’×¢×” ×œ×™×¢×“ ×‘×“×¨×š ×”×§×¦×¨×” â€” ××” ×”×¤×ª×¨×•×Ÿ ×”×™×©×¨××œ×™?",
          "options": [], "answer": "Waze (×•×•×™×™×–).", "hint": "" },

        { "id": "achievements-7", "points": 10, "type": "for_everyone",
          "image": "design/problem.jpg",
          "question": "×‘×¢×™×”: ×™×¨×™ ×˜×™×œ×™× â€” ××” ×”×¤×ª×¨×•×Ÿ ×”×”×’× ×ª×™ ×”×™×©×¨××œ×™?",
          "options": [], "answer": "×›×™×¤×ª ×‘×¨×–×œ.", "hint": "" }
      ]
    }
  }
};


/* === State === */
const DEFAULT_STATE = {
  phase: "intro",          // start | board | duel | end
  teamCount: 2,
  teams: [],
  currentTeamIndex: 0,
  used: {},
  duel: null,              // {catKey, qIndex, revealed}
  undoStack: []            // stack of snapshots
};

let state = loadState() || clone(DEFAULT_STATE);

/* === Utils === */
function $(id) { return document.getElementById(id); }
function clone(obj) {
  if (typeof structuredClone === "function") return structuredClone(obj);
  return JSON.parse(JSON.stringify(obj));
}
function saveState() { localStorage.setItem("amIsraelGameState", JSON.stringify(state)); }
function loadState() {
  try { return JSON.parse(localStorage.getItem("amIsraelGameState")); }
  catch { return null; }
}
function resetState() {
  localStorage.removeItem("amIsraelGameState");
  state = clone(DEFAULT_STATE);
}
function setText(id, text) {
  const el = $(id);
  if (el) el.textContent = text;
}
function showOnlyScreen(screenId) {
  ["screenIntro", "screenStart", "screenBoard", "screenDuel", "screenEnd"].forEach(id => {
    const el = $(id);
    if (el) el.classList.add("hidden");
  });
  const target = $(screenId);
  if (target) target.classList.remove("hidden");
}


/* === Intro === */
const INTRO_LOGO_SRC = "design/logo.png"; // logo path
const INTRO_SUBTITLE = "××©×—×§ ×˜×¨×™×•×•×™×” ×§×‘×•×¦×ª×™";

function renderIntroScreen() {
  const wrap = $("introWrap");
  if (!wrap) return;

  const title = escapeHtml(QUESTIONS?.meta?.title || "×× ×™ ×•×”×¡×™×¤×•×¨ ×©×œ× ×•");

  wrap.innerHTML = `
    <div class="card introCard">
      <div class="introTitle">${title}</div>
      <div class="introSubtitle">${escapeHtml(INTRO_SUBTITLE)}</div>

      <div class="introActions">
        <button id="btnIntroGo" class="btn btn-primary" type="button">
          ××ª×—×™×œ×™× â–¶
        </button>
      </div>

      <div class="introHint">
       ×˜×™×¤: ××¤×©×¨ ×œ×‘×˜×œ ×¤×¢×•×œ×” ×¢× U, ×•×œ×¡×™×™× ××©×—×§ ×¢× E
      </div>

      <div class="introLogoDock">
        <img class="introLogo" src="${escapeHtml(INTRO_LOGO_SRC)}" alt="×œ×•×’×• ×”×¢××•×ª×”"
             onerror="this.style.display='none'"/>
      </div>
    </div>
  `;

  $("btnIntroGo")?.addEventListener("click", () => {
    pushUndo();
    state.phase = "start";
    saveState();
    applyStateToUI();
  });
}


/* === Undo === */
function snapshotForUndo() {
  const snap = clone(state);
  snap.undoStack = []; // do not clone undo history inside snapshot
  return snap;
}
function pushUndo() {
  if (state.phase === "start") return;

  const stack = Array.isArray(state.undoStack) ? state.undoStack : [];
  stack.push(snapshotForUndo());
  while (stack.length > 50) stack.shift();
  state.undoStack = stack;
  saveState();
}
function undoLastAction() {
  const stack = Array.isArray(state.undoStack) ? state.undoStack : [];
  if (!stack.length) {
    alert("××™×Ÿ ××” ×œ×‘×˜×œ ğŸ™‚");
    return;
  }
  const prev = stack.pop();
  prev.undoStack = stack;
  state = prev;
  saveState();
  applyStateToUI();
}

/* === Game rules helpers === */
function rowsCount() {
  return QUESTIONS?.meta?.board?.rows
    || Math.max(...Object.values(QUESTIONS.categories).map(c => c.questions.length));
}
function getQuestionBy(catKey, index0) {
  const cat = QUESTIONS.categories[catKey];
  if (!cat) return null;
  return cat.questions[index0] || null;
}
function getQuestionPoints(q) { return Number(q?.points || 0); }

function typeLabel(q){
  const base =
    q.type === "personal" ? "××™×©×™×ª" :
    q.type === "for_everyone" ? "×œ×›×•×œ×" :
    q.type === "duel" ? "×“×•Ö¾×§×¨×‘" :
    "×¨×’×™×œ×”";

  const extra = (q.autoScore === true) ? " â€¢ ×××¨×™×§××™" : "";
  return base + extra;
}

/* === Auto-score helper === */
function isAutoTrivia(q) {
  const hasOptions = Array.isArray(q?.options) && q.options.length > 0;
  const hasAnswer = String(q?.answer ?? "").trim() !== "";
  const flag = q?.autoScore === true;
  return (flag && hasOptions && hasAnswer) || (hasOptions && hasAnswer);
}

/* === Start screen === */
function buildTeamsForm(teamCount) {
  const wrap = $("teamsForm");
  if (!wrap) return;
  wrap.innerHTML = "";
  for (let i = 0; i < teamCount; i++) {
    const row = document.createElement("div");
    row.className = "team-row";
    row.innerHTML = `
      <label class="team-label">×§×‘×•×¦×” ${i + 1}</label>
      <input class="team-input" id="teamName${i}" type="text" placeholder="×©× ×§×‘×•×¦×” ${i + 1}" />
    `;
    wrap.appendChild(row);
  }
}
function initTeamsFromForm() {
  const teamCount = Number($("teamCount")?.value || 2);
  state.teamCount = teamCount;
  state.teams = [];
  for (let i = 0; i < teamCount; i++) {
    const name = ($(`teamName${i}`)?.value || `×§×‘×•×¦×” ${i + 1}`).trim() || `×§×‘×•×¦×” ${i + 1}`;
    state.teams.push({ name, score: 0 });
  }
  state.currentTeamIndex = 0;
  state.used = {};
  state.duel = null;
  state.undoStack = [];
  state.phase = "board";
  saveState();
}

/* === Board UI === */
function renderScoreBar() {
  const bar = $("scoreBar");
  if (!bar) return;
  bar.innerHTML = "";
  state.teams.forEach((t, i) => {
    const pill = document.createElement("div");
    pill.className = "score-pill" + (i === state.currentTeamIndex ? " active" : "");
    pill.textContent = `${t.name}: ${t.score}`;
    bar.appendChild(pill);
  });
}
function renderTurnLabel() {
  const el = $("turnLabel");
  if (!el) return;
  const t = state.teams[state.currentTeamIndex];
  el.textContent = t ? `×ª×•×¨: ${t.name}` : "";
}

function buildBoard() {
  const board = $("board");
  if (!board) return;

  board.innerHTML = "";

  const order = QUESTIONS.meta.categoriesOrder;
  const rCount = rowsCount();

  // Header row (categories)
  order.forEach(catKey => {
    const cell = document.createElement("div");
    cell.className = "board-cell board-header";
    cell.dataset.cat = catKey;
    cell.textContent = QUESTIONS.categories[catKey]?.label || catKey;
    board.appendChild(cell);
  });

  // Rows: question numbers
  for (let r = 0; r < rCount; r++) {
    const displayNumber = r + 1;

    order.forEach(catKey => {
      const q = getQuestionBy(catKey, r);

      const btn = document.createElement("button");
      btn.className = "board-cell board-btn";
      btn.type = "button";
      btn.textContent = String(displayNumber);

      btn.dataset.cat = catKey;
      btn.dataset.qindex = String(r);
      btn.dataset.qid = q?.id || "";

      const isUsed = q?.id ? !!state.used[q.id] : true;
      btn.disabled = !q || isUsed;
      if (btn.disabled) btn.classList.add("used");

      btn.addEventListener("click", () => {
        if (!q) return;

        // duel questions must go through duel screen (prep + "show question")
        if (q.type === "duel") {
          openDuel(catKey, r);
        } else {
          openQuestionModal(catKey, r);
        }
      });

      board.appendChild(btn);
    });
  }
}

function advanceTurn() {
  if (!state.teams.length) return;
  state.currentTeamIndex = (state.currentTeamIndex + 1) % state.teams.length;
  saveState();
  renderScoreBar();
  renderTurnLabel();
}
function rerenderBoardUI() {
  renderScoreBar();
  renderTurnLabel();
  buildBoard();
}

/* === Modal logic === */
let activeCatKey = null;
let activeQIndex = null;
let timerInterval = null;
let timerRemaining = 0;

function markUsed(catKey, qIndex) {
  const q = getQuestionBy(catKey, qIndex);
  if (!q?.id) return;
  state.used[q.id] = true;
  saveState();
}

function confirmBurnIfNeeded() {
  if (!CONFIRM_BURN_QUESTION) return true;
  return confirm("×œ×¡××Ÿ ××ª ×”×©××œ×” ×›'×©×•××©×”' ×•×œ×¢×‘×•×¨ ×”×œ××”?");
}

function openQuestionModal(catKey, qIndex) {
  activeCatKey = catKey;
  activeQIndex = qIndex;

  const q = getQuestionBy(catKey, qIndex);
  if (!q) return;

  // Safety routing: duel questions should never open in the modal
  if (q.type === "duel") {
    openDuel(catKey, qIndex);
    return;
  }

  const points = getQuestionPoints(q);
  const displayNumber = qIndex + 1;

  setText("modalCategory", QUESTIONS.categories[catKey]?.label || catKey);
  const mm = $("modalMeta");
  if (mm) {
    mm.innerHTML = `
    <span>×©××œ×” ${displayNumber}</span>
    <span class="metaDot">â€¢</span>
    <span>${points} × ×§×•×“×•×ª</span>
    <span class="metaDot">â€¢</span>
    <span class="qBadge">${escapeHtml(typeLabel(q))}</span>
  `;
}

  setText("modalQuestion", q.question || "");

    // media (image)
  const media = $("modalMedia");
  const img = $("modalImage");
  const src = String(q.image || "").trim();

  if (media && img) {
    if (src) {
      img.src = src;
      img.alt = q.question ? q.question : "×ª××•× ×” ×œ×©××œ×”";
      img.onerror = () => {
        // ×× ×§×•×‘×¥ ×œ× × ××¦× - ×¤×©×•×˜ ××¡×ª×™×¨×™× ×›×“×™ ×œ× ×œ×©×‘×•×¨ ××ª ×”××¡×š
        media.classList.add("hidden");
        img.removeAttribute("src");
      };
      media.classList.remove("hidden");
    } else {
      media.classList.add("hidden");
      img.removeAttribute("src");
    }
  }

  // options
  const optWrap = $("modalOptions");
  if (optWrap) {
    optWrap.innerHTML = "";
    const hasOptions = Array.isArray(q.options) && q.options.length > 0;

    if (hasOptions) {
      optWrap.classList.remove("hidden");

      q.options.forEach(opt => {
        const b = document.createElement("button");
        b.className = "option-btn";
        b.type = "button";
        b.textContent = opt;

        b.addEventListener("click", () => {
          optWrap.querySelectorAll(".option-btn").forEach(x => x.classList.remove("selected"));
          b.classList.add("selected");

          if (isAutoTrivia(q)) {
            optWrap.querySelectorAll(".option-btn").forEach(x => (x.disabled = true));

            const chosen = String(opt).trim();
            const correct = String(q.answer).trim();

            if (chosen === correct) {
              pushUndo();
              awardPoints(state.currentTeamIndex, points);
            } else {
              if (!confirmBurnIfNeeded()) {
                optWrap.querySelectorAll(".option-btn").forEach(x => (x.disabled = false));
                return;
              }
              pushUndo();
              markUsed(activeCatKey, activeQIndex);
              closeQuestionModal();
              advanceTurn();
              rerenderBoardUI();
            }
          }
        });

        optWrap.appendChild(b);
      });
    } else {
      optWrap.classList.add("hidden");
    }
  }

  // answer area reset
  const ans = $("modalAnswer");
  if (ans) {
    ans.classList.add("hidden");
    ans.textContent = "";
  }

  $("btnShowAnswer")?.classList.remove("hidden");

  if (!isAutoTrivia(q)) {
    renderTeamAwardButtons(points);
  } else {
    const wrap = $("teamButtons");
    if (wrap) wrap.innerHTML = "";
    const none = $("btnNoPoints");
    if (none) {
      none.onclick = () => {
        if (!confirmBurnIfNeeded()) return;
        pushUndo();
        markUsed(activeCatKey, activeQIndex);
        closeQuestionModal();
        advanceTurn();
        rerenderBoardUI();
      };
    }
  }

  stopTimer();
  updateTimerUI(0, 0);

  $("modalOverlay")?.classList.remove("hidden");
}

function closeQuestionModal() {
  $("modalOverlay")?.classList.add("hidden");
  stopTimer();
  activeCatKey = null;
  activeQIndex = null;
  const media = $("modalMedia");
  const img = $("modalImage");
  if (media) media.classList.add("hidden");
  if (img) img.removeAttribute("src");
}

function renderTeamAwardButtons(points) {
  const wrap = $("teamButtons");
  if (!wrap) return;
  wrap.innerHTML = "";

  state.teams.forEach((t, idx) => {
    const b = document.createElement("button");
    b.className = "team-award-btn";
    b.type = "button";
    b.textContent = `×œ×ª×ª × ×§×•×“×•×ª ×œÖ¾${t.name}`;
    b.addEventListener("click", () => {
      pushUndo();
      awardPoints(idx, points);
    });
    wrap.appendChild(b);
  });

  const none = $("btnNoPoints");
  if (none) {
    none.onclick = () => {
      if (!confirmBurnIfNeeded()) return;
      pushUndo();
      markUsed(activeCatKey, activeQIndex);
      closeQuestionModal();
      advanceTurn();
      rerenderBoardUI();
    };
  }
}

function awardPoints(teamIndex, points) {
  if (teamIndex == null) return;
  const pts = Number(points || 0);

  if (state.teams[teamIndex]) {
    state.teams[teamIndex].score += pts;
  }

  markUsed(activeCatKey, activeQIndex);
  saveState();

  closeQuestionModal();
  advanceTurn();
  rerenderBoardUI();
}

/* === Timer === */
function startTimer(seconds) {
  stopTimer();
  const total = Number(seconds || 0);
  if (total <= 0) {
    updateTimerUI(0, 0);
    return;
  }

  timerRemaining = total;
  updateTimerUI(timerRemaining, total);

  timerInterval = setInterval(() => {
    timerRemaining -= 1;
    if (timerRemaining <= 0) {
      stopTimer();
      updateTimerUI(0, total);
      return;
    }
    updateTimerUI(timerRemaining, total);
  }, 1000);
}
function stopTimer() {
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = null;
}

function updateTimerUI(remaining, total) {
  const bar = $("timerBar");
  const fill = $("timerFill");
  const text = $("timerText");
  if (!bar || !fill || !text) return;

  if (!total || total <= 0) {
    bar.classList.add("hidden");
    fill.style.width = "0%";
    text.textContent = "";
    return;
  }

  bar.classList.remove("hidden");
  const pct = Math.max(0, Math.min(1, remaining / total));
  fill.style.width = `${pct * 100}%`;
  text.textContent = `${remaining}s`;
}

/* === Duel logic (2-stage) === */
function openDuel(catKey, qIndex) {
  state.phase = "duel";
  state.duel = { catKey, qIndex, revealed: false };
  saveState();
  renderDuelFromState();
  showOnlyScreen("screenDuel");
}

function closeDuel(goNextTurnIfRevealed) {
  if (goNextTurnIfRevealed) {
    if (!confirmBurnIfNeeded()) return;
    pushUndo();
    markUsed(state.duel?.catKey, state.duel?.qIndex);
    state.phase = "board";
    state.duel = null;
    saveState();
    advanceTurn();
    rerenderBoardUI();
    showOnlyScreen("screenBoard");
    return;
  }

  state.phase = "board";
  state.duel = null;
  saveState();
  showOnlyScreen("screenBoard");
}

function renderDuelFromState() {
  const d = state.duel;
  if (!d) return;

  const q = getQuestionBy(d.catKey, d.qIndex);
  if (!q) return;

  const points = getQuestionPoints(q);
  const displayNumber = d.qIndex + 1;
  const catLabel = QUESTIONS.categories[d.catKey]?.label || d.catKey;
  const dm = $("duelMeta");

  if (dm) {
  dm.innerHTML = `
    <span>${escapeHtml(catLabel)}</span>
    <span class="metaDot">â€¢</span>
    <span>×©××œ×” ${displayNumber}</span>
    <span class="metaDot">â€¢</span>
    <span>${points} × ×§×•×“×•×ª</span>
    <span class="metaDot">â€¢</span>
    <span class="qBadge">${escapeHtml(typeLabel(q))}</span>
  `;
}

  setText("duelIntro", d.revealed ? "×‘×—×¨×• ×× ×¦×—:" : "×“×•Ö¾×§×¨×‘! ×§×•×“× ×›×œ ×›×•×œ× ××•×›× ×™×. ×¨×§ ××—×¨×™ ×–×” ×œ×•×—×¦×™× '×”×¦×’ ×©××œ×”'.");

  const area = $("duelQuestionArea");
  const qText = $("duelQuestionText");
  const showBtn = $("btnDuelShowQuestion");

  if (area) area.classList.toggle("hidden", !d.revealed);
  if (showBtn) showBtn.disabled = !!d.revealed;

  if (d.revealed) {
    if (qText) qText.textContent = q.question || "";

    const b0 = $("btnDuelWinnerTeam0");
    const b1 = $("btnDuelWinnerTeam1");
    const b2 = $("btnDuelWinnerTeam2");

    if (b0) {
      b0.textContent = `× ×™×¦×—×•×Ÿ: ${state.teams[0]?.name ?? "×§×‘×•×¦×” 1"}`;
      b0.classList.remove("hidden");
    }
    if (b1) {
      b1.textContent = `× ×™×¦×—×•×Ÿ: ${state.teams[1]?.name ?? "×§×‘×•×¦×” 2"}`;
      b1.classList.remove("hidden");
    }
    if (b2) {
      if (state.teams.length >= 3) {
        b2.textContent = `× ×™×¦×—×•×Ÿ: ${state.teams[2]?.name ?? "×§×‘×•×¦×” 3"}`;
        b2.classList.remove("hidden");
      } else {
        b2.classList.add("hidden");
      }
    }
    
    const media = $("duelMedia");
    const img = $("duelImage");
    const src = String(q.image || "").trim();

    if (media && img) {
      if (src) {
        img.src = src;
        img.alt = q.question ? q.question : "×ª××•× ×” ×œ×©××œ×”";
        img.onerror = () => {
          media.classList.add("hidden");
          img.removeAttribute("src");
        };
        media.classList.remove("hidden");
      } else {
        media.classList.add("hidden");
        img.removeAttribute("src");
      }
    }
  }
}

function awardDuelWinner(teamIndex) {
  const d = state.duel;
  if (!d) return;

  const q = getQuestionBy(d.catKey, d.qIndex);
  if (!q) return;

  pushUndo();

  const points = getQuestionPoints(q);
  if (state.teams[teamIndex]) {
    state.teams[teamIndex].score += Number(points || 0);
  }

  markUsed(d.catKey, d.qIndex);
  state.phase = "board";
  state.duel = null;
  saveState();

  advanceTurn();
  rerenderBoardUI();
  showOnlyScreen("screenBoard");
}

/* === End game (UPDATED: podium + ties) === */
function computePlacements() {
  const teams = (state.teams || []).map((t, idx) => ({
    idx,
    name: t.name,
    score: Number(t.score || 0)
  }));

  // group by score
  const scoreToTeams = new Map();
  teams.forEach(t => {
    if (!scoreToTeams.has(t.score)) scoreToTeams.set(t.score, []);
    scoreToTeams.get(t.score).push(t);
  });

  // distinct scores desc
  const scores = Array.from(scoreToTeams.keys()).sort((a, b) => b - a);

  const groups = scores.map((score, i) => ({
    place: i + 1,           // place by distinct score order (not by team count)
    score,
    teams: scoreToTeams.get(score)
  }));

  // Only need up to 3 podium levels
  const podium = groups.slice(0, 3);

  // detect tie states
  const tieFirst = podium[0]?.teams?.length > 1;
  const tieSecond = podium[1]?.teams?.length > 1;
  const tieThird = podium[2]?.teams?.length > 1;

  return { podium, tieFirst, tieSecond, tieThird };
}

function renderTeamBadges(teamsArr, score) {
  // teamsArr: [{name, score, idx}]
  const chips = teamsArr.map(t => {
    return `
      <div style="
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding:10px 12px;
        border-radius:16px;
        border:1px solid rgba(11,18,32,.10);
        background:rgba(255,255,255,.86);
        box-shadow:0 10px 18px rgba(11,18,32,.08);
        font-weight:900;
        margin:6px 0;
        max-width:100%;
      ">
        <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:260px;">${escapeHtml(t.name)}</span>
        <span style="opacity:.75; font-weight:950;">â€¢</span>
        <span style="white-space:nowrap;">${score} × ×§×³</span>
      </div>
    `;
  }).join("");

  return `
    <div style="display:flex; flex-direction:column; align-items:center; width:100%;">
      ${chips}
    </div>
  `;
}

function escapeHtml(str) {
  return String(str ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function renderEndScreen() {
  const wrap = $("endRanking");
  if (!wrap) return;

  const { podium } = computePlacements();

  // helper to get group by desired podium slot:
  // We always want visual slots: 2nd (left), 1st (center), 3rd (right)
  const g1 = podium[0] || null; // best score
  const g2 = podium[1] || null;
  const g3 = podium[2] || null;

  const teamCount = state.teams?.length || 0;

  // Titles with tie awareness
  const titleFor = (visualPlace, group) => {
    if (!group) return "";
    const isTie = (group.teams?.length || 0) > 1;
    if (isTie) return `×ª×™×§×• ×‘××§×•× ${visualPlace}`;
    return `××§×•× ${visualPlace}`;
  };

  // If only 2 teams, never show 3rd block
  const showThird = teamCount >= 3 && !!g3;

  // If there is no 2nd score (everyone tied on first), g2 null.
  // In that case, we will not show a "2nd" podium.
  const showSecond = !!g2;

  // Build podium blocks
  const block = ({ place, group, height, emoji }) => {
    if (!group) return `<div style="flex:1; min-width:220px;"></div>`;

    const isTie = (group.teams?.length || 0) > 1;

    return `
      <div style="
        flex:1;
        min-width:220px;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-end;
        gap:12px;
      ">
        <div style="
          width:100%;
          max-width:320px;
          padding:12px 12px 10px;
          border-radius:18px;
          border:1px solid rgba(11,18,32,.10);
          background:rgba(255,255,255,.88);
          box-shadow:0 12px 20px rgba(11,18,32,.10);
          text-align:center;
        ">
          <div style="font-weight:950; font-size:${place === 1 ? 18 : 16}px;">
            ${emoji} ${titleFor(place, group)}
          </div>
          <div style="margin-top:8px;">
            ${renderTeamBadges(group.teams, group.score)}
          </div>
          ${isTie ? `<div style="margin-top:6px; font-size:12px; opacity:.7;">(××•×ª×• × ×™×§×•×“)</div>` : ``}
        </div>

        <div style="
          width:100%;
          max-width:320px;
          height:${height}px;
          border-radius:18px;
          background:linear-gradient(180deg, rgba(56,189,248,.26), rgba(29,78,216,.08));
          border:1px solid rgba(29,78,216,.12);
          box-shadow:0 18px 32px rgba(11,18,32,.10);
          display:flex;
          align-items:flex-end;
          justify-content:center;
          padding:10px;
          font-weight:950;
          font-size:${place === 1 ? 22 : 18}px;
          color:rgba(11,18,32,.85);
        ">
          ${place}
        </div>
      </div>
    `;
  };

  const headerText = g1 && (g1.teams?.length || 0) > 1
    ? "××™×–×” ×™×•×¤×™! ×™×© ×ª×™×§×• ×‘××§×•× ×”×¨××©×•×Ÿ ğŸ‰"
    : "×›×œ ×”×›×‘×•×“! ×”× ×” ×”×“×™×¨×•×’ ×”×¡×•×¤×™ ğŸ‰";

  wrap.innerHTML = `
    <div style="width:100%; display:flex; flex-direction:column; gap:14px;">
      <div style="text-align:center; font-weight:950; font-size:18px; opacity:.9;">
        ${headerText}
      </div>

      <div style="
        display:flex;
        gap:18px;
        align-items:flex-end;
        justify-content:center;
        flex-wrap:wrap;
      ">
        ${showSecond ? block({ place: 2, group: g2, height: 150, emoji: "ğŸ¥ˆ" }) : `<div style="flex:1; min-width:220px;"></div>`}
        ${block({ place: 1, group: g1, height: 210, emoji: "ğŸ¥‡" })}
        ${showThird ? block({ place: 3, group: g3, height: 125, emoji: "ğŸ¥‰" }) : `<div style="flex:1; min-width:220px;"></div>`}
      </div>

      <div style="
        margin-top:4px;
        text-align:center;
        font-size:13px;
        opacity:.7;
      ">
        ×›×œ ×”×›×‘×•×“ ×œ×›×œ ×”××©×ª×ª×¤×™×! ğŸ˜Š
      </div>
    </div>
  `;
}

function finishGame(withConfirm = true) {
  if (withConfirm) {
    const ok = confirm("×œ×¡×™×™× ××ª ×”××©×—×§ ×•×œ×¢×‘×•×¨ ×œ××¡×š ×“×™×¨×•×’?");
    if (!ok) return;
  }
  state.phase = "end";
  saveState();
  renderEndScreen();
  showOnlyScreen("screenEnd");
}

/* === Wiring === */
function wireTopButtons() {
  const resetBtn = $("btnReset");
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      resetState();
      applyStateToUI();
    });
  }

  const resumeBtn = $("btnResume");
  if (resumeBtn) {
    resumeBtn.addEventListener("click", () => {
      const loaded = loadState();
      if (!loaded) return;
      state = loaded;
      applyStateToUI();
    });
  }

  const finishBtn = $("btnFinish");
  if (finishBtn) {
    finishBtn.addEventListener("click", () => finishGame(true));
  }

  const undoBtn = $("btnUndo");
  if (undoBtn) {
    undoBtn.addEventListener("click", undoLastAction);
  }
}

function wireStartScreen() {
  const teamCountSel = $("teamCount");
  if (teamCountSel) {
    teamCountSel.addEventListener("change", () => buildTeamsForm(Number(teamCountSel.value)));
  }

  const startBtn = $("btnStart");
  if (startBtn) {
    startBtn.addEventListener("click", () => {
      initTeamsFromForm();
      applyStateToUI();
    });
  }
}

function wireModalButtons() {
  $("btnCloseModal")?.addEventListener("click", closeQuestionModal);

  $("btnHelpTeacher")?.addEventListener("click", () => {
    startTimer(0);
    alert("×¢×–×¨×ª ××•×¨×” ×”×•×¤×¢×œ×” (×”×× ×—×” ××—×œ×™×˜ ××™×š ×œ×¢×–×•×¨).");
  });

  $("btnHelpGoogle")?.addEventListener("click", () => {
    startTimer(20);
  });

  $("btnShowAnswer")?.addEventListener("click", () => {
    const q = getQuestionBy(activeCatKey, activeQIndex);
    if (!q) return;
    const ans = $("modalAnswer");
    if (ans) {
      ans.textContent = `×ª×©×•×‘×”: ${q.answer ?? ""}`;
      ans.classList.remove("hidden");
    }
  });

  $("modalOverlay")?.addEventListener("click", (e) => {
    if (e.target && e.target.id === "modalOverlay") closeQuestionModal();
  });
}

function wireDuelButtons() {
  $("btnDuelShowQuestion")?.addEventListener("click", () => {
    if (!state.duel) return;
    pushUndo();
    state.duel.revealed = true;
    saveState();
    renderDuelFromState();
  });

  $("btnDuelBack")?.addEventListener("click", () => {
    const revealed = !!state.duel?.revealed;
    closeDuel(revealed);
  });

  $("btnDuelWinnerTeam0")?.addEventListener("click", () => awardDuelWinner(0));
  $("btnDuelWinnerTeam1")?.addEventListener("click", () => awardDuelWinner(1));
  $("btnDuelWinnerTeam2")?.addEventListener("click", () => awardDuelWinner(2));
}

function wireEndButtons() {
  $("btnEndPlayAgain")?.addEventListener("click", () => {
    resetState();
    applyStateToUI();
  });

  $("btnEndBackToBoard")?.addEventListener("click", () => {
    state.phase = "board";
    saveState();
    applyStateToUI();
  });
}

function wireKeyboardShortcuts() {
  document.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea") return;

    if (e.key === "Escape") {
      const modalVisible = !$("modalOverlay")?.classList.contains("hidden");
      if (modalVisible) {
        closeQuestionModal();
        return;
      }

      if (state.phase === "duel" && state.duel) {
        if (state.duel.revealed) {
          pushUndo();
          state.duel.revealed = false;
          saveState();
          renderDuelFromState();
        } else {
          closeDuel(false);
        }
      }
    }

    if (e.key === "u" || e.key === "U") {
      undoLastAction();
    }

    if (e.key === "e" || e.key === "E") {
      finishGame(true);
    }
  });
}

/* === Apply state === */
function applyStateToUI() {
    // intro screen first (until user clicks "××ª×—×™×œ×™×")
  if (state.phase === "intro") {
    saveState();
    renderIntroScreen();
    showOnlyScreen("screenIntro");
    return;
  }

  if (!state.teams || !state.teams.length) {
    state.phase = "start";
    saveState();
    showOnlyScreen("screenStart");
    buildTeamsForm(Number($("teamCount")?.value || 2));
    return;
  }

  if (state.phase === "end") {
    renderEndScreen();
    showOnlyScreen("screenEnd");
    return;
  }

  if (state.phase === "duel" && state.duel) {
    showOnlyScreen("screenDuel");
    renderDuelFromState();
    return;
  }

  showOnlyScreen("screenBoard");
  renderScoreBar();
  renderTurnLabel();
  buildBoard();
}

function boot() {
  wireTopButtons();
  wireStartScreen();
  wireModalButtons();
  wireDuelButtons();
  wireEndButtons();
  wireKeyboardShortcuts();

  buildTeamsForm(Number($("teamCount")?.value || 2));

  const loaded = loadState();
  if (loaded) state = loaded;

  applyStateToUI();
}

document.addEventListener("DOMContentLoaded", boot);

















